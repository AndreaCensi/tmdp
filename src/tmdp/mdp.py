from abc import abstractmethod
from collections import defaultdict
from fractions import Fraction

from contracts import ContractsMeta, new_contract
from numpy.core.numeric import allclose

from memos import memoize_instance
from reprep.utils import frozendict2


__all__ = ['SimpleMDP']


class SimpleMDP():
    __metaclass__ = ContractsMeta


    @new_contract
    def is_action(self, action):
        pass

    @new_contract
    def is_state(self, state):
        pass

    def is_state_dist(self, state_dist):
        for s in state_dist:
            self.is_state(s)
        p = sum(state_dist.values())
        p = float(p)
        if not allclose(p, 1.0):
            raise ValueError('PD sums to %f' % p)

    def is_state_set(self, x):
        for s in x:
            self.is_state(s)
        
    @abstractmethod
    def states(self):
        """ 
            Returns an iterable with states. States are small
            hashable objects (like tuples, strings, etc.). 
        """

    @abstractmethod
    def actions(self, state):
        pass
    
    @abstractmethod
    def transition(self, state, action):
        pass

    @abstractmethod
    def reward(self, state, action, state2):
        pass

    @abstractmethod
    def get_start_dist(self):
        """ Return the start distribution (episodic) """
        pass

    def evolve_actions(self, state_dist, actions):
        p = state_dist
        for a in actions:
            self.is_action(a)
            p = p.evolve(p, a)
        return p

    def evolve(self, state_dist, action, use_fraction=False):
        self.is_state_dist(state_dist)
        if use_fraction:
            p2 = defaultdict(lambda:Fraction(0))
        else:
            p2 = defaultdict(lambda:Fraction(0.0))
        for s1, p_s1 in state_dist.items():
            conditional = self.transition(s1, action)
            self.is_state_dist(conditional)
            for s2, p_s2 in conditional.items():
                if  p_s2 * p_s1 > 0:
                    p2[s2] += p_s2 * p_s1
        for s in list(p2):
            if p2[s] == 0:
                del p2[s]
        return frozendict2(p2)

    # Debug
    @abstractmethod
    def display_state_dist(self, pylab, state_dist):
        """ 
            dist: hash states -> value >= 0 
        """
        pass

    @abstractmethod
    def display_state_values(self, pylab, state_values):
        pass

    @abstractmethod
    def display_policy(self, pylab, det_policy):
        pass

class SimplePOMDP(SimpleMDP):

    def get_observations(self):
        """ Returns a list of all possible observations. """
        pass

    def get_observations_dist(self, state):
        """ Returns the pd of observations given state. """

    def get_observations_dist_given_belief(self, belief, use_fraction=False):
        if use_fraction:
            p = defaultdict(lambda:Fraction(0))
        else:
            p = defaultdict(lambda:0.0)
        for state, p_state in belief.items():
            for y, p_y in self.get_observations_dist(state).items():
                # print('y', y, 'p_y', p_y)
                if p_state * p_y > 0:
                    p[y] += p_state * p_y
        return dict(**p)

    @memoize_instance
    def likelihood(self, state, observations):
        p = self.get_observations_dist(state=state)
        if not observations in p:
            return 0
#             msg = 'Tried to compute p(y|x) where:\n\ty =
#  %s\n\tx = %s ' % (observations, state)
#             msg += '\nBut p(y|x) is:\n\t%s ' % p
#             raise ValueError(msg)
        return p[observations]

    def inference(self, belief, observations, use_fraction=False):
        belief2 = dict()
        p_y = self.partition(observations=observations, state_dist=belief,
                             use_fraction=use_fraction)
        if p_y == 0:
            msg = ('Tried to compute inference of p(x) given y but y '
                    'cannot be generated by any x in p(x)')
#             msg += '\nBut p(y|x) is:\n\t%s ' % p
#
            raise SimplePOMDP.ObsNotPossible(msg)
        for x, p_x in belief.items():
            p_y_given_x = self.likelihood(observations=observations, state=x)
            p2 = p_x * p_y_given_x / p_y
            if p2 > 0:
                belief2[x] = p2

        belief2 = frozendict2(belief2.items())

        s = sum(belief2.values())
        if not s == 1.0:
            msg = 'Expected %s, got %s. ' % (1.0, s)
            msg += '\n %s' % belief2
            raise Exception(msg)
        return belief2

    def partition(self, state_dist, observations, use_fraction=False):
        if use_fraction:
            p = Fraction(0)
        else:
            p = 0.0
        # p(y) = p(y|x) * p(x)
        for state, p_state in state_dist.items():
            p += p_state * self.likelihood(state=state,
                                           observations=observations)
        return p

    class ObsNotPossible(Exception):
        pass

